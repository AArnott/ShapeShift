<#@ assembly name="System.Core" #>
<#@ Import Namespace="System.Collections.Generic" #>
<#@ Import Namespace="System.Linq" #>
// Copyright (c) Andrew Arnott. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

/* THIS (.cs) FILE IS GENERATED. DO NOT CHANGE IT.
 * CHANGE THE .tt FILE INSTEAD. */

#pragma warning disable SA1306 // Field names should begin with lower-case letter
#pragma warning disable SA1309 // Field names should not begin with underscore

using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

namespace ShapeShift.Converters;

<#
var convertersByType = new List<ConverterInfo>
{
	new ConverterInfo("int", "Int32Converter"),
	new ConverterInfo("string", "StringConverter", IsRefType: true),
};
#>
/// <summary>
/// Provides access to built-in converters for primitive types.
/// </summary>
/// <typeparam name="TEncoder"><inheritdoc cref="SerializerBase{TEncoder, TEncoder}" path="/typeparam[@name='TEncoder']"/></typeparam>
/// <typeparam name="TDecoder"><inheritdoc cref="SerializerBase{TEncoder, TDecoder}" path="/typeparam[@name='TDecoder']"/></typeparam>
/// <remarks>
/// <para>This class is carefully crafted to avoid assembly loads by testing type names
/// rather than types directly for types declared in assemblies that may not be loaded.</para>
/// <para>On .NET, this class is also carefully crafted to help trimming be effective by avoiding type references
/// to types that are not used in the application.
/// Although the retrieval method references all the types, the fact that it is generic gives the
/// JIT/AOT compiler the opportunity to only reference types that match the type argument
/// (at least for the value types).
/// The generic method itself leads to more methods to JIT at runtime when NativeAOT is *not* used.
/// It's a trade-off, which is why we never use the generic method on .NET Framework where NativeAOT isn't even an option.
/// </para>
/// </remarks>
internal static class PrimitiveConverterLookup<TEncoder, TDecoder>
	where TEncoder : IEncoder, allows ref struct
	where TDecoder : IDecoder, allows ref struct
{
<# foreach (var converterGroup in convertersByType.GroupBy(c => c.PreprocessorCondition)) {
	 if (converterGroup.Key is not null) { #>
#if <#=converterGroup.Key#>
<#   }
	 foreach (var converter in converterGroup) { #>
	private static IShapeShiftConverterInternal<TEncoder, TDecoder>? <#=converter.FieldName#>;
<#	  if (converter.IsRefType) { #>
	private static IShapeShiftConverterInternal<TEncoder, TDecoder>? <#=converter.ReferencePreservingFieldName#>;
<#	  }
	 }
	 if (converterGroup.Key is not null) { #>
#endif
<#   }
} #>

#if NET
	/// <summary>
	/// Gets a built-in converter for the given type, if one is available.
	/// </summary>
	/// <typeparam name="T">The type to get a converter for.</typeparam>
	/// <param name="referencePreserving">Indicates whether a reference-preserving converter is requested.</param>
	/// <param name="converter">Receives the converter, if one is available.</param>
	/// <returns><see langword="true" /> if a converter was found; <see langword="false" /> otherwise.</returns>
	internal static bool TryGetPrimitiveConverter<T>(ReferencePreservationMode referencePreserving, [NotNullWhen(true)] out ShapeShiftConverter<T, TEncoder, TDecoder>? converter)
#else
	/// <summary>
	/// Gets a built-in converter for the given type, if one is available.
	/// </summary>
	/// <param name="type">The type to get a converter for.</param>
	/// <param name="referencePreserving">Indicates whether a reference-preserving converter is requested.</param>
	/// <param name="converter">Receives the converter, if one is available.</param>
	/// <returns><see langword="true" /> if a converter was found; <see langword="false" /> otherwise.</returns>
	internal static bool TryGetPrimitiveConverter(Type type, ReferencePreservationMode referencePreserving, [NotNullWhen(true)] out ShapeShiftConverter<TEncoder, TDecoder>? converter)
#endif
	{
<# foreach (var converterGroup in convertersByType.Where(c => !c.LazyLoad).GroupBy(c => c.PreprocessorCondition)) {
	 if (converterGroup.Key is not null) { #>
#if <#=converterGroup.Key#>
<#   }
	 foreach (var converter in converterGroup) {
		string featureCondition = converter.Feature is not null ? $" && Features.{converter.Feature}" : string.Empty; #>
#if NET
		if (typeof(T) == typeof(<#=converter.TypeName#>)<#=featureCondition#>)
#else
		if (type == typeof(<#=converter.TypeName#>)<#=featureCondition#>)
#endif
		{
<#
	if (converter.IsRefType) {
#>
			if (referencePreserving != ReferencePreservationMode.Off)
			{
#if NET
				converter = (ShapeShiftConverter<T, TEncoder, TDecoder>)(<#=converter.ReferencePreservingFieldName#> ??= new <#= converter.ConverterName #><TEncoder, TDecoder>().WrapWithReferencePreservation());
#else
				converter = (MessagePackConverter)(<#=converter.ReferencePreservingFieldName#> ??= new <#= converter.ConverterName #><TEncoder, TDecoder>().WrapWithReferencePreservation());
#endif
			}
			else
			{
#if NET
				converter = (ShapeShiftConverter<T, TEncoder, TDecoder>)(<#=converter.FieldName#> ??= new <#= converter.ConverterName #><TEncoder, TDecoder>());
#else
				converter = (MessagePackConverter)(<#=converter.FieldName#> ??= new <#= converter.ConverterName #><TEncoder, TDecoder>());
#endif
			}

<# } else { #>
#if NET
			converter = (ShapeShiftConverter<T, TEncoder, TDecoder>)(<#=converter.FieldName#> ??= new <#= converter.ConverterName #><TEncoder, TDecoder>());
#else
			converter = (MessagePackConverter)(<#=converter.FieldName#> ??= new <#= converter.ConverterName #><TEncoder, TDecoder>());
#endif
<# } #>
			return true;
		}

<#   }
	 if (converterGroup.Key is not null) { #>
#endif
<#   }
} #>

#if NET
		string primitiveTypeName = typeof(T).Name;
#else
		string primitiveTypeName = type.Name;
#endif
		string? primitiveTypeNamespace = null;

<# foreach (var converterGroup in convertersByType.Where(c => c.LazyLoad).GroupBy(c => c.PreprocessorCondition)) {
	 if (converterGroup.Key is not null) { #>
#if <#=converterGroup.Key#>
<#   }
	 foreach (var converter in converterGroup) {
		// Type.Name is cheap, but not free.
		// Type.Namespace is more expensive.
		// Type.FullName is the most expensive.
		// Therefore, we only obtain these properties when we must.
		string leafName = converter.TypeName.Substring(converter.TypeName.LastIndexOf('.') + 1);
		string ns = converter.TypeName.Substring(0, converter.TypeName.LastIndexOf('.'));
		string featureCondition = converter.Feature is not null ? $" && Features.{converter.Feature}" : string.Empty; #>
#if NET
		if (primitiveTypeName == "<#=leafName#>" && (primitiveTypeNamespace ??= typeof(T).Namespace) == "<#=ns#>"<#=featureCondition#>)
#else
		if (primitiveTypeName == "<#=leafName#>" && (primitiveTypeNamespace ??= type.Namespace) == "<#=ns#>"<#=featureCondition#>)
#endif
		{
<#
	if (converter.IsRefType) {
#>
			if (referencePreserving != ReferencePreservationMode.Off)
			{
#if NET
				converter = (ShapeShiftConverter<T, TEncoder, TDecoder>?)(<#=converter.ReferencePreservingFieldName#> ??= Create<#=converter.ConverterName#><T>().WrapWithReferencePreservation());
#else
				converter = (MessagePackConverter?)(<#=converter.ReferencePreservingFieldName#> ??= Create<#=converter.ConverterName#><T>().WrapWithReferencePreservation());
#endif
			}
			else
			{
#if NET
				converter = (ShapeShiftConverter<T, TEncoder, TDecoder>?)(<#=converter.FieldName#> ??= Create<#=converter.ConverterName#><T>());
#else
				converter = (MessagePackConverter?)(<#=converter.FieldName#> ??= Create<#=converter.ConverterName#><T>());
#endif
			}

<# } else { #>
#if NET
			converter = (ShapeShiftConverter<T, TEncoder, TDecoder>?)(<#=converter.FieldName#> ??= Create<#=converter.ConverterName#><T>());
#else
			converter = (MessagePackConverter?)(<#=converter.FieldName#> ??= Create<#=converter.ConverterName#>(type));
#endif
<# } #>
			return converter is not null;
		}

<#   }
	 if (converterGroup.Key is not null) { #>
#endif
<#   }
} #>
		converter = null;
		return false;
	}
<# foreach (var converter in convertersByType.Where(c => c.LazyLoad)) { 
    // The runtime type check serves both to ensure type identity beyond string comparison
    // and (perhaps more importantly) to preserve trimming of unused types, since the trimmer
    // does not trim based on string comparisons.
#>

	[MethodImpl(MethodImplOptions.NoInlining)]
#if NET
	private static IShapeShiftConverterInternal<TEncoder, TDecoder>? Create<#=converter.ConverterName#><T>() => typeof(T) == typeof(<#=converter.TypeName#>) ? new <#=converter.ConverterName#>() : null;
#else
	private static IShapeShiftConverterInternal<TEncoder, TDecoder>? Create<#=converter.ConverterName#>(Type type) => type == typeof(<#=converter.TypeName#>) ? new <#=converter.ConverterName#>() : null;
#endif
<# } #>
}
<#+
record struct ConverterInfo(string TypeName, string ConverterName, string PreprocessorCondition = null, bool IsRefType = false, string Feature = null)
{
	internal string FieldName => $"_{ConverterName}";
	internal string ReferencePreservingFieldName => $"{FieldName}ReferencePreserving";
	internal bool LazyLoad { get; set; }
}
#>
