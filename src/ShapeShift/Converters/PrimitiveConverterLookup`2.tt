<#@ assembly name="System.Core" #>
<#@ Import Namespace="System.Collections.Generic" #>
<#@ Import Namespace="System.Linq" #>
// Copyright (c) Andrew Arnott. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

/* THIS (.cs) FILE IS GENERATED. DO NOT CHANGE IT.
 * CHANGE THE .tt FILE INSTEAD. */

#pragma warning disable SA1306 // Field names should begin with lower-case letter
#pragma warning disable SA1309 // Field names should not begin with underscore

using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

namespace ShapeShift.Converters;

<#
var convertersByType = new List<ConverterInfo>
{
	new ConverterInfo("bool", "BooleanConverter"),
	new ConverterInfo("char", "CharConverter"),
	new ConverterInfo("byte", "ByteConverter"),
	new ConverterInfo("sbyte", "SByteConverter"),
	new ConverterInfo("short", "Int16Converter"),
	new ConverterInfo("ushort", "UInt16Converter"),
	new ConverterInfo("int", "Int32Converter"),
	new ConverterInfo("uint", "UInt32Converter"),
	new ConverterInfo("long", "Int64Converter"),
	new ConverterInfo("ulong", "UInt64Converter"),
	new ConverterInfo("Int128", "Int128Converter"),
	new ConverterInfo("UInt128", "UInt128Converter"),
	new ConverterInfo("Half", "HalfConverter"),
	new ConverterInfo("float", "SingleConverter"),
	new ConverterInfo("double", "DoubleConverter"),
	new ConverterInfo("decimal", "DecimalConverter"),
	new ConverterInfo("DateTime", "DateTimeConverter"),
	new ConverterInfo("DateTimeOffset", "DateTimeOffsetConverter"),
	new ConverterInfo("TimeSpan", "TimeSpanConverter"),
	new ConverterInfo("System.Numerics.BigInteger", "BigIntegerConverter") { LazyLoad = true },
	new ConverterInfo("System.Text.Rune", "RuneConverter"),
	new ConverterInfo("string", "StringConverter", IsRefType: true),
};
#>
/// <summary>
/// Provides access to built-in converters for primitive types.
/// </summary>
/// <typeparam name="TEncoder"><inheritdoc cref="ShapeShiftSerializer{TEncoder, TEncoder}" path="/typeparam[@name='TEncoder']"/></typeparam>
/// <typeparam name="TDecoder"><inheritdoc cref="ShapeShiftSerializer{TEncoder, TDecoder}" path="/typeparam[@name='TDecoder']"/></typeparam>
/// <remarks>
/// <para>This class is carefully crafted to avoid assembly loads by testing type names
/// rather than types directly for types declared in assemblies that may not be loaded.</para>
/// <para>On .NET, this class is also carefully crafted to help trimming be effective by avoiding type references
/// to types that are not used in the application.
/// Although the retrieval method references all the types, the fact that it is generic gives the
/// JIT/AOT compiler the opportunity to only reference types that match the type argument
/// (at least for the value types).
/// The generic method itself leads to more methods to JIT at runtime when NativeAOT is *not* used.
/// It's a trade-off, which is why we never use the generic method on .NET Framework where NativeAOT isn't even an option.
/// </para>
/// </remarks>
internal static class PrimitiveConverterLookup<TEncoder, TDecoder>
	where TEncoder : IEncoder, allows ref struct
	where TDecoder : IDecoder, allows ref struct
{
<# foreach (var converterGroup in convertersByType.GroupBy(c => c.PreprocessorCondition)) {
	 if (converterGroup.Key is not null) { #>
#if <#=converterGroup.Key#>
<#   }
	 foreach (var converter in converterGroup) { #>
	private static IShapeShiftConverterInternal<TEncoder, TDecoder>? <#=converter.FieldName#>;
<#	  if (converter.IsRefType) { #>
	private static IShapeShiftConverterInternal<TEncoder, TDecoder>? <#=converter.ReferencePreservingFieldName#>;
<#	  }
	 }
	 if (converterGroup.Key is not null) { #>
#endif
<#   }
} #>

	/// <summary>
	/// Gets a built-in converter for the given type, if one is available.
	/// </summary>
	/// <typeparam name="T">The type to get a converter for.</typeparam>
	/// <param name="referencePreserving">Indicates whether a reference-preserving converter is requested.</param>
	/// <param name="converter">Receives the converter, if one is available.</param>
	/// <returns><see langword="true" /> if a converter was found; <see langword="false" /> otherwise.</returns>
	internal static bool TryGetPrimitiveConverter<T>(ReferencePreservationMode referencePreserving, [NotNullWhen(true)] out ShapeShiftConverter<T, TEncoder, TDecoder>? converter)
	{
<# foreach (var converterGroup in convertersByType.Where(c => !c.LazyLoad).GroupBy(c => c.PreprocessorCondition)) {
	 if (converterGroup.Key is not null) { #>
#if <#=converterGroup.Key#>
<#   }
	 foreach (var converter in converterGroup) {
		string featureCondition = converter.Feature is not null ? $" && Features.{converter.Feature}" : string.Empty; #>
		if (typeof(T) == typeof(<#=converter.TypeName#>)<#=featureCondition#>)
		{
<#
	if (converter.IsRefType) {
#>
			if (referencePreserving != ReferencePreservationMode.Off)
			{
				converter = (ShapeShiftConverter<T, TEncoder, TDecoder>)(<#=converter.ReferencePreservingFieldName#> ??= new <#= converter.ConverterName #><TEncoder, TDecoder>().WrapWithReferencePreservation());
			}
			else
			{
				converter = (ShapeShiftConverter<T, TEncoder, TDecoder>)(<#=converter.FieldName#> ??= new <#= converter.ConverterName #><TEncoder, TDecoder>());
			}

<# } else { #>
			converter = (ShapeShiftConverter<T, TEncoder, TDecoder>)(<#=converter.FieldName#> ??= new <#= converter.ConverterName #><TEncoder, TDecoder>());
<# } #>
			return true;
		}

<#   }
	 if (converterGroup.Key is not null) { #>
#endif
<#   }
} #>
		string primitiveTypeName = typeof(T).Name;
		string? primitiveTypeNamespace = null;
<# foreach (var converterGroup in convertersByType.Where(c => c.LazyLoad).GroupBy(c => c.PreprocessorCondition)) {
	 if (converterGroup.Key is not null) { #>
#if <#=converterGroup.Key#>
<#   }
	 foreach (var converter in converterGroup) {
		// Type.Name is cheap, but not free.
		// Type.Namespace is more expensive.
		// Type.FullName is the most expensive.
		// Therefore, we only obtain these properties when we must.
		string leafName = converter.TypeName.Substring(converter.TypeName.LastIndexOf('.') + 1);
		string ns = converter.TypeName.Substring(0, converter.TypeName.LastIndexOf('.'));
		string featureCondition = converter.Feature is not null ? $" && Features.{converter.Feature}" : string.Empty; #>
		if (primitiveTypeName == "<#=leafName#>" && (primitiveTypeNamespace ??= typeof(T).Namespace) == "<#=ns#>"<#=featureCondition#>)
		{
<#
	if (converter.IsRefType) {
#>
			if (referencePreserving != ReferencePreservationMode.Off)
			{
				converter = (ShapeShiftConverter<T, TEncoder, TDecoder>?)(<#=converter.ReferencePreservingFieldName#> ??= Create<#=converter.ConverterName#><T>().WrapWithReferencePreservation());
			}
			else
			{
				converter = (ShapeShiftConverter<T, TEncoder, TDecoder>?)(<#=converter.FieldName#> ??= Create<#=converter.ConverterName#><T>());
			}

<# } else { #>
			converter = (ShapeShiftConverter<T, TEncoder, TDecoder>?)(<#=converter.FieldName#> ??= Create<#=converter.ConverterName#><T>());
<# } #>
			return converter is not null;
		}

<#   }
	 if (converterGroup.Key is not null) { #>
#endif
<#   }
} #>
		converter = null;
		return false;
	}
<# foreach (var converter in convertersByType.Where(c => c.LazyLoad)) { 
    // The runtime type check serves both to ensure type identity beyond string comparison
    // and (perhaps more importantly) to preserve trimming of unused types, since the trimmer
    // does not trim based on string comparisons.
#>

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static IShapeShiftConverterInternal<TEncoder, TDecoder>? Create<#=converter.ConverterName#><T>() => typeof(T) == typeof(<#=converter.TypeName#>) ? new <#=converter.ConverterName#><TEncoder, TDecoder>() : null;
<# } #>
}
<#+
record struct ConverterInfo(string TypeName, string ConverterName, string PreprocessorCondition = null, bool IsRefType = false, string Feature = null)
{
	internal string FieldName => $"_{ConverterName}";
	internal string ReferencePreservingFieldName => $"{FieldName}ReferencePreserving";
	internal bool LazyLoad { get; set; }
}
#>
